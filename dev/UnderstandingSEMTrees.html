<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Understanding the main parts of the semtree() function</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="UnderstandingSEMTrees_files/libs/clipboard/clipboard.min.js"></script>
<script src="UnderstandingSEMTrees_files/libs/quarto-html/quarto.js"></script>
<script src="UnderstandingSEMTrees_files/libs/quarto-html/popper.min.js"></script>
<script src="UnderstandingSEMTrees_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="UnderstandingSEMTrees_files/libs/quarto-html/anchor.min.js"></script>
<link href="UnderstandingSEMTrees_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="UnderstandingSEMTrees_files/libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="UnderstandingSEMTrees_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="UnderstandingSEMTrees_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="UnderstandingSEMTrees_files/libs/bootstrap/bootstrap-fb4d276130138317a835dc35d7ed6e6e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="mermaid-theme" content="default">
<script src="UnderstandingSEMTrees_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="UnderstandingSEMTrees_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="UnderstandingSEMTrees_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#main-function" id="toc-main-function" class="nav-link active" data-scroll-target="#main-function">Main Function</a></li>
  <li><a href="#recursive-partitioning-component" id="toc-recursive-partitioning-component" class="nav-link" data-scroll-target="#recursive-partitioning-component">Recursive partitioning component</a>
  <ul class="collapse">
  <li><a href="#node-class" id="toc-node-class" class="nav-link" data-scroll-target="#node-class"><code>node</code> class</a></li>
  </ul></li>
  <li><a href="#naivesplit" id="toc-naivesplit" class="nav-link" data-scroll-target="#naivesplit">naiveSplit()</a></li>
  <li><a href="#easier-way" id="toc-easier-way" class="nav-link" data-scroll-target="#easier-way">Easier Way</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding the main parts of the semtree() function</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="main-function" class="level1">
<h1>Main Function</h1>
<p>Sequence diagram of major parts of <code>semtree::semtree()</code> function.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">sequenceDiagram
autonumber
Title: [semtree() main function using lavaan]
    actor semtree()
    participant semtree.constraints()
    participant semtree.control()
    participant getPredictorsLavaan()
    participant setGlobal()

    semtree.constraints()-&gt;&gt; semtree(): GET multigroup parameter constraints. 
    semtree.control()-&gt;&gt; semtree(): GET model fitting settings.
    getPredictorsLavaan() -&gt;&gt; semtree(): GET column numbers of indicators and splitting covariates
    setGlobal() -&gt;&gt; semtree(): GET environment.id of the root node
    growTree() -&gt;&gt; semtree(): START recursive partitioning
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="recursive-partitioning-component" class="level1">
<h1>Recursive partitioning component</h1>
<p><code>semtree::growTree()</code> function is found in <code>growTree.R</code></p>
<div class="cell" data-htmllabels="false" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    %% A[Start] 
    %% A --&gt; B
    subgraph routine[Entire Routine]
    direction TB
    subgraph pre
    direction LR
    B[Create 'node' class] --&gt; C["Sample columns (RF)"]
    C --&gt; D["Check forced splits"]
    end
    subgraph father [Father Node]
    direction LR
    %% D --&gt; 
    E[Is depth == 0?]
    E -- TRUE --&gt; E1[Inherit model &lt;br&gt; from argument]
    E -- FALSE --&gt; E2[Estimate model &lt;br&gt; using lavaan]
    E1 --&gt; F["Assign model &lt;br&gt; to node$model"]
    E2 --&gt; F
    F --&gt; G["Model convergence OK?"]
    G -- TRUE --&gt; G1[Do nothing]
    G -- FALSE --&gt; G2["Assign NULL to
    node$model
    w/ error msg"]
    G1 --&gt; H["Store parameter &lt;br&gt; estimates in &lt;br&gt; node$params"]
    G2 --&gt; H
    end
    pre --&gt; father
    subgraph df [Degree of Freedom]
    direction LR
    %% H --&gt; 
    I["Are there &lt;br&gt; focus parameters?"]
    I -- TRUE --&gt; I1["df = number of &lt;br&gt; focus parameters"]
    I -- FALSE --&gt; I2["df = number of &lt;br&gt; parameters"]
    end
    father --&gt; df
    df --&gt; splitting
    subgraph splitting[Splitting procedure]
    direction TB
    J["Use getGlobal() to set
    node_id based on
    environment name"]
    J --&gt; K["Split using one of 
    naiveSplit(), ScoreSplit(),
    fairSplit(
    control$fair3Step =
    TRUE/FALSE)"]
    K --&gt; K1["naiveSplit()"]
    K --&gt; K2["ScoreSplit()"] 
    K --&gt; K3["fairSplit()"]
    K3 --&gt; K3A["fairSplit(control$fair3Step &lt;br&gt; == TRUE)"]
    K3 --&gt; K3B["fairSplit(control$fair3Step &lt;br&gt; == FALSE)"]
    K1 --&gt; L["Assign output &lt;br&gt; of split &lt;br&gt; in result"]
    K2 --&gt; L
    K3A --&gt; L
    K3B --&gt; L
    L --&gt; M["Assign or &lt;br&gt; Compute p-value &lt;br&gt; of split &lt;br&gt; to node$p"]
    M --&gt; N[Is stopping rule &lt;br&gt; TRUE or FALSE?]
    N --&gt; O["Using result$type.max: &lt;br&gt; prepare data based &lt;br&gt; on data type of &lt;br&gt; splitting covariate"]
    O -- .SCALE_CATEGORICAL --&gt; O1["Nominal Covariate"]
    O -- .SCALE.METRIC --&gt; O2["Numerical Covariate"]
    O -- .SCALE_ORDINAL --&gt; O3["Ordinal Covariate"]
    O1 --&gt; P[Create sub1 &lt;br&gt; and sub2  &lt;br&gt;datasets]
    O2 --&gt; P
    O3 --&gt; P
    end
    end
    subgraph recursion
    direction LR
    subgraph left
    Q1["Assign growTree(sub2) &lt;br&gt; to node$left_child"]
    end
    subgraph right
    Q2["Assign growTree(sub1) &lt;br&gt; to node$right_child"]
    end
    end
    routine --&gt; recursion
    recursion --&gt; routine
    %% recursion --&gt; R
    Q1 --&gt; R["Return to semtree()"]
    Q2 --&gt; R
%% TODO: fix text and subgraph formatting, make it easy to explore
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Notes:</p>
<ul>
<li><p><code>meta</code> is the column number of indicators and of splitting covariates</p></li>
<li><p><code>mydata</code> is the data</p></li>
<li><p>When <code>control$method</code> is <code>fair</code>, <code>semtree</code> takes the user-provided data and creates an internal hold-out set. This is different from the way most ML libraries work because they usually require you to create the hold-out set yourself.</p></li>
</ul>
<section id="node-class" class="level2">
<h2 class="anchored" data-anchor-id="node-class"><code>node</code> class</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">classDiagram
class node{
    +list left_child
    +list right_child
    +string caption
    +int N}

class node{
    +bool p.values.valid
    +string edge_label
    +string term.reason
    +list model
    +list params 
    +list params_sd 
    +list param_names 
    +int df
    +string node_id
    +numeric lr
    +list result
    +list rule
    +string caption
    +list left_child
    +list right_child
}
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Notes:</p>
<ul>
<li><code>model</code> can either be a fitted model or an empty template model from lavaan, specifically <code>lavaan::growth(model = model, data = growth.data, do.fit = FALSE)</code>.</li>
</ul>
</section>
</section>
<section id="naivesplit" class="level1">
<h1>naiveSplit()</h1>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">%% TODO: This problem here
flowchart TB
    A["Create lavaan
    command for
    node$model"] 
    B["Fit model of 
    node$model using 
    safeRunAndEvaluate()
    ??? UNCLEAR IF 
    ROOT OR PARENT ???"]
    C["Assign model's
    LL to LL.overall"]
    D[Assign meta$covariate.ids
     to comparedData]
    A --&gt; B --&gt; C --&gt; D
    D --iteratively--&gt; iter
    
    subgraph iter[For each covariate]
        E[Assign fitted model's
        LL to LL.baseline]
        subgraph submodels[For each splitpoint]
            F[Create data subset 
            as subset1 and 
            subset2]
            subgraph fitSubmodels["fitSubmodels()"]
            G["Fit separate models
            for subset1
            and subset2"]
            H["Sum each LL
            to get MGA-LL"]
            I["cbind() difference 
            between LL.baseline
            and MGA-LL into 
        LL.within"]
        G --&gt; H --&gt; I
        end
        F --&gt; fitSubmodels
        end
        E -- nominal --&gt; submodels
        E -- ordinal --&gt; submodels
        E -- numeric --&gt; submodels
    end
    iter --&gt; J[Create btn.matrix
    from every
    LL.within 
    and friends]
    J --&gt; K[Assign largest
    LL.within to LL.max] --&gt; L[EXIT]
    
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Notes:</p>
<ul>
<li><mark> Is <code>node$model</code> always the same root model or does it change recursively? </mark></li>
<li>Within this function, <code>LL.within</code> always starts from nothing and all the possible split points from here are considered.</li>
</ul>
</section>
<section id="easier-way" class="level1">
<h1>Easier Way</h1>
<p>The easiest way to understand this is probably to use the new Vignette on SPI. This is mentioned in <code>UnderstandingSEMTrees.R</code>.</p>
<p>The conclusion is that at every split, we only test against the immediate parent node and not the most ancestral root node. We also do not compare against the entire preceding multigroup model before we attempt to find a split.</p>
<p>There are a few heuristics:</p>
<ul>
<li><p>The number of rows of <code>mydata</code> decreases with every iteration of <code>growTree()</code></p></li>
<li><p>At the end of <code>growTree()</code>, <code>sub2</code> is passed on recursively to another <code>growTree</code> and its number of rows is less than <code>mydata.</code></p></li>
<li><p>In <code>naiveSplit()</code>, the <code>LL.overall</code> should correspond to the immediate parent node.</p></li>
<li><p>You can also see the likelihood ratio differences in these two code snippets. Without thinking too deeply, I’m pretty sure that the differences shouldn’t match up between the two unless the comparisons are being done on only the immediate parent</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(spi_tree_naive <span class="ot">&lt;-</span> <span class="fu">semtree</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> two_dim_fit,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> spi_analysis,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">control =</span> <span class="fu">semtree_control</span>(<span class="at">method=</span><span class="st">"naive"</span>, <span class="at">max.depth =</span> <span class="dv">3</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(sem_tree_subset <span class="ot">&lt;-</span> <span class="fu">semtree</span>(</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> two_dim_fit,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> spi_analysis[spi_analysis<span class="sc">$</span>age<span class="sc">&lt;=</span><span class="fl">39.5</span> <span class="sc">&amp;</span> spi_analysis<span class="sc">$</span>age <span class="sc">&gt;=</span><span class="fl">20.5</span>,],</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">control =</span> <span class="fu">semtree_control</span>(<span class="at">method=</span><span class="st">"naive"</span>, <span class="at">max.depth =</span> <span class="dv">3</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>